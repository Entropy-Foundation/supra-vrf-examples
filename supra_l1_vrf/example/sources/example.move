module example::example {
    use std::string;
    use aptos_std::table;

    use supra_addr::deposit::{Self, SupraVRFPermit};
    use supra_addr::supra_vrf;

    // ===========================
    // Structs
    // ===========================

    /// Marker struct for identifying this VRF client module
    struct ClientExample has store {}

    /// Global storage for random numbers generated by Supra VRF
    /// Maps nonce values to their corresponding random number vectors
    struct RandomNumberList has key {
        random_numbers: table::Table<u64, vector<u256>>
    }

    /// Capability struct that holds the VRF permit
    /// This permit authorizes this module to interact with Supra VRF
    struct PermitCap has key {
        permit: SupraVRFPermit<ClientExample>
    }

    // ===========================
    // Initialization
    // ===========================

    /// Initializes the module on deployment
    /// Creates the VRF permit and random number storage
    ///
    /// @param sender - The account deploying this module
    fun init_module(sender: &signer) {
        // Initialize VRF permit for this module
        let permit = deposit::init_vrf_module<ClientExample>(sender);

        // Create empty table to store random numbers
        move_to(sender, RandomNumberList {
            random_numbers: table::new()
        });

        // Store the permit capability
        move_to(sender, PermitCap { permit });
    }

    // ===========================
    // Public Entry Functions
    // ===========================

    /// Requests random numbers from Supra VRF
    ///
    /// @param rng_count - Number of random values to generate (1-255)
    /// @param client_seed - Client-provided seed for randomness
    /// @param num_confirmations - Number of block confirmations required before callback
    ///
    /// Returns a nonce that can be used to retrieve the generated numbers later
    public entry fun rng_request(
        rng_count: u8,
        client_seed: u64,
        num_confirmations: u64
    ) acquires RandomNumberList, PermitCap {
        // Define the callback function that will receive the random numbers
        let callback_function = string::utf8(b"distribute");

        // Request random numbers from Supra VRF
        // Returns a nonce to identify this request
        let nonce = supra_vrf::rng_request_v2<ClientExample>(
            &borrow_global<PermitCap>(@example).permit,
            callback_function,
            rng_count,
            client_seed,
            num_confirmations,
        );

        // Initialize empty vector for this nonce in storage
        // The actual random numbers will be populated in the callback
        let random_num_list = &mut borrow_global_mut<RandomNumberList>(@example).random_numbers;
        table::add(random_num_list, nonce, vector[]);
    }

    /// Callback function invoked by Supra VRF with verified random numbers
    /// This function is called automatically after the VRF generates random values
    ///
    /// @param nonce - Unique identifier for this VRF request
    /// @param message - VRF-generated message containing random data
    /// @param signature - Cryptographic signature proving authenticity
    /// @param caller_address - Address that initiated the VRF request
    /// @param rng_count - Number of random values requested
    /// @param client_seed - Original client seed used in the request
    public entry fun distribute(
        nonce: u64,
        message: vector<u8>,
        signature: vector<u8>,
        caller_address: address,
        rng_count: u8,
        client_seed: u64,
    ) acquires RandomNumberList {
        // Verify the VRF callback and extract random numbers
        let verified_num: vector<u256> = supra_vrf::verify_callback(
            nonce,
            message,
            signature,
            caller_address,
            rng_count,
            client_seed
        );

        // Store the verified random numbers in the table
        let random_num_list = &mut borrow_global_mut<RandomNumberList>(@example).random_numbers;
        let random_num = table::borrow_mut(random_num_list, nonce);
        *random_num = verified_num;
    }

    /// Removes the VRF module and cleans up the permit
    /// Should only be called when decommissioning the module
    public entry fun remove_module() acquires PermitCap {
        // Extract the permit from storage
        let PermitCap { permit } = move_from<PermitCap>(@example);

        // Properly clean up the VRF module
        deposit::remove_module<ClientExample>(permit);
    }

    // ===========================
    // View Functions
    // ===========================

    /// Retrieves the random numbers generated for a specific nonce
    ///
    /// @param nonce - The nonce returned from rng_request
    /// @return Vector of u256 random numbers
    #[view]
    public fun get_rng_number_from_nonce(nonce: u64): vector<u256> acquires RandomNumberList {
        let random_num_list = borrow_global<RandomNumberList>(@example);
        *table::borrow(&random_num_list.random_numbers, nonce)
    }
}